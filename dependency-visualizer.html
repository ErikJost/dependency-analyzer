<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dependency Graph Visualization</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    html, body { 
      margin: 0; 
      padding: 0; 
      width: 100%; 
      height: 100%; 
      font-family: Arial, sans-serif; 
      overflow: hidden; 
    }
    
    svg {
      width: 100%;
      height: 100%;
      position: absolute;
      top: 0;
      left: 0;
    }
    
    .links line { stroke: #999; stroke-opacity: 0.6; }
    .links line.duplicate { stroke: #9932cc; stroke-width: 2px; stroke-opacity: 0.8; }
    .nodes circle { stroke: #fff; stroke-width: 1.5px; }
    .node-label { font-size: 10px; }
    
    /* Missing node styling */
    .missing-node line {
      stroke: #d62728;
      stroke-width: 2px;
    }
    
    .missing-link {
      stroke: #d62728;
      stroke-dasharray: 5,5;
      stroke-width: 1.5px;
    }
    
    /* Panel styling */
    .widget {
      position: absolute;
      background: rgba(255,255,255,0.95);
      padding: 10px;
      border-radius: 5px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      max-height: 80vh;
      overflow-y: auto;
      transition: all 0.3s ease;
    }
    
    .widget-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
      padding-bottom: 5px;
      border-bottom: 1px solid #ddd;
      cursor: move;
    }
    
    .widget-title {
      font-weight: bold;
      margin: 0;
    }
    
    .widget-controls {
      display: flex;
    }
    
    .widget-control {
      cursor: pointer;
      margin-left: 8px;
      user-select: none;
    }
    
    .widget-content {
      overflow: hidden;
      transition: max-height 0.3s ease;
    }
    
    .legend { 
      top: 10px; 
      left: 10px; 
      z-index: 100;
    }
    
    .tools {
      top: 10px;
      right: 10px;
      z-index: 100;
    }
    
    .minimized .widget-content {
      max-height: 0;
      padding: 0;
      overflow: hidden;
    }
    
    .duplicate-group { stroke: #9932cc; stroke-width: 2px; }
    
    /* Error container */
    #error-container {
      display: none;
      position: fixed;
      bottom: 10px;
      left: 10px;
      background: rgba(255,70,70,0.9);
      color: white;
      padding: 10px;
      border-radius: 5px;
      max-width: 80%;
      z-index: 1000;
      box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    }
    
    /* Input styling */
    input, select, button {
      margin: 5px 0;
      padding: 6px 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 14px;
    }
    
    button {
      background: #4a90e2;
      color: white;
      border: none;
      cursor: pointer;
      padding: 6px 12px;
    }
    
    button:hover {
      background: #3a70b2;
    }
    
    .filter-group {
      margin-bottom: 10px;
    }
    
    .filter-title {
      font-weight: bold;
      margin-bottom: 5px;
    }
    
    .search-result {
      margin-top: 10px;
      padding: 8px;
      background: #f0f0f0;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <!-- Legend Widget -->
  <div class="widget legend" id="legend-widget">
    <div class="widget-header">
      <h3 class="widget-title">Legend</h3>
      <div class="widget-controls">
        <span class="widget-control minimize-btn" title="Minimize">−</span>
      </div>
    </div>
    <div class="widget-content">
      <div><span style="color: #1f77b4;">●</span> client/src</div>
      <div><span style="color: #ff7f0e;">●</span> src</div>
      <div><span style="color: #2ca02c;">●</span> other</div>
      <div><span style="color: #d62728;">✕</span> missing files</div>
      <div><span style="color: #999;">—</span> imports</div>
      <div><span style="color: #ff0000;">—</span> re-exports</div>
      <div><span style="color: #9932cc;">—</span> duplicates (1 groups)</div>
      <div><span style="color: #d62728; stroke-dasharray: 5,5;">- -</span> missing dependency</div>
    </div>
  </div>
  
  <!-- Tools Widget -->
  <div class="widget tools" id="tools-widget">
    <div class="widget-header">
      <h3 class="widget-title">Tools</h3>
      <div class="widget-controls">
        <span class="widget-control minimize-btn" title="Minimize">−</span>
      </div>
    </div>
    <div class="widget-content">
      <div class="filter-group">
        <div class="filter-title">Filter by Folder</div>
        <select id="folder-filter">
          <option value="">All Folders</option>
          <option value="client/src">client/src</option>
          <option value="src">src</option>
          <option value="shared">shared</option>
          <option value="functions">functions</option>
          <option value="scripts">scripts</option>
        </select>
        <div>
          <label><input type="checkbox" id="show-missing" checked> Show missing nodes</label>
        </div>
        <div>
          <label><input type="checkbox" id="show-labels" checked> Show node labels</label>
        </div>
        <div>
          <label><input type="checkbox" id="show-duplicates" checked> Show duplicate connections</label>
        </div>
      </div>
      
      <div class="filter-group">
        <div class="filter-title">Search Nodes</div>
        <input type="text" id="search-input" placeholder="Enter file name...">
        <button id="search-btn">Search</button>
        <div id="search-results" class="search-result" style="display: none;"></div>
      </div>
      
      <div class="filter-group">
        <div class="filter-title">Debug</div>
        <button id="center-btn">Reset View</button>
        <button id="inspect-data-btn">Inspect Data</button>
      </div>
    </div>
  </div>
  
  <!-- Error message container -->
  <div id="error-container"></div>
  
  <svg></svg>
  
  <script>
    // Make widgets draggable
    function makeWidgetDraggable(widgetId) {
      const widget = document.getElementById(widgetId);
      const header = widget.querySelector('.widget-header');
      let isDragging = false;
      let offsetX, offsetY;
      
      header.addEventListener('mousedown', (e) => {
        isDragging = true;
        offsetX = e.clientX - widget.getBoundingClientRect().left;
        offsetY = e.clientY - widget.getBoundingClientRect().top;
        widget.style.cursor = 'grabbing';
      });
      
      document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        
        const x = e.clientX - offsetX;
        const y = e.clientY - offsetY;
        
        // Keep widget within window bounds
        const maxX = window.innerWidth - widget.offsetWidth;
        const maxY = window.innerHeight - widget.offsetHeight;
        
        widget.style.left = Math.max(0, Math.min(x, maxX)) + 'px';
        widget.style.top = Math.max(0, Math.min(y, maxY)) + 'px';
      });
      
      document.addEventListener('mouseup', () => {
        isDragging = false;
        widget.style.cursor = 'default';
      });
    }
    
    // Add minimize/maximize functionality
    function setupMinimizeButtons() {
      document.querySelectorAll('.minimize-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const widget = btn.closest('.widget');
          widget.classList.toggle('minimized');
          
          // Update button text
          if (widget.classList.contains('minimized')) {
            btn.textContent = '+';
            btn.title = 'Maximize';
          } else {
            btn.textContent = '−';
            btn.title = 'Minimize';
          }
        });
      });
    }
    
    // Display error messages
    function showError(message) {
      console.error(message);
      const errorContainer = document.getElementById('error-container');
      if (errorContainer) {
        errorContainer.textContent = message;
        errorContainer.style.display = 'block';
        
        // Hide after 10 seconds
        setTimeout(() => {
          errorContainer.style.display = 'none';
        }, 10000);
      }
    }
    
    // Initialize widgets
    document.addEventListener('DOMContentLoaded', () => {
      makeWidgetDraggable('legend-widget');
      makeWidgetDraggable('tools-widget');
      setupMinimizeButtons();
    });
  
    fetch('dependency-graph.json')
      .then(response => response.json())
      .then(data => {
        const svg = d3.select("svg");
        const width = window.innerWidth;
        const height = window.innerHeight;
        
        // Store the original data
        const originalData = JSON.parse(JSON.stringify(data));
        let filteredData = JSON.parse(JSON.stringify(data));
        
        // Create a map of node IDs for quick lookup
        const nodeMap = new Map();
        data.nodes.forEach(node => {
          nodeMap.set(node.id, node);
        });
        console.log(`Created node map with ${nodeMap.size} entries`);
        
        // Find missing nodes in the links
        const missingNodes = new Set();
        const missingLinks = [];
        
        // Identify missing nodes referenced in links
        data.links.forEach(link => {
          const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
          const targetId = typeof link.target === 'object' ? link.target.id : link.target;
          
          if (!nodeMap.has(sourceId)) {
            missingNodes.add(sourceId);
            // Don't add the link, just track it
            missingLinks.push({source: sourceId, target: targetId, missing: 'source'});
          } else if (!nodeMap.has(targetId)) {
            missingNodes.add(targetId);
            // Don't add the link, just track it
            missingLinks.push({source: sourceId, target: targetId, missing: 'target'});
          }
        });
        
        // Add missing nodes to the visualization with a different style
        if (missingNodes.size > 0) {
          console.log(`Found ${missingNodes.size} missing nodes, adding them to visualization`);
          
          // Create new nodes for missing files
          missingNodes.forEach(missingId => {
            const parts = missingId.split('/');
            const group = missingId.startsWith('client/') ? 1 : 
                        missingId.startsWith('src/') ? 2 : 0;
            
            // Add the missing node to data
            data.nodes.push({
              id: missingId,
              group: group,
              missing: true
            });
            
            // Also add to the original data for filtering
            originalData.nodes.push({
              id: missingId,
              group: group,
              missing: true
            });
          });
          
          // Add filtered links back
          missingLinks.forEach(link => {
            data.links.push({
              source: link.source,
              target: link.target,
              value: 1,
              missing: true
            });
            
            // Also add to the original data for filtering
            originalData.links.push({
              source: link.source,
              target: link.target,
              value: 1,
              missing: true
            });
          });
          
          // Show error message about missing nodes
          showError(`Found ${missingNodes.size} missing nodes referenced in the dependencies. These are shown with red X marks.`);
        }
        
        // Setup visualization
        function createVisualization(data) {
          // Clear the SVG
          svg.selectAll("*").remove();
          svg.attr("width", width)
             .attr("height", height);
             
          // Create a container for all content
          const container = svg.append("g")
            .attr("class", "container");
          
          // Add a background for pan/zoom
          container.append("rect")
            .attr("width", width * 10)
            .attr("height", height * 10)
            .attr("x", -width * 5)
            .attr("y", -height * 5)
            .attr("fill", "none")
            .attr("pointer-events", "all");
  
          const simulation = d3.forceSimulation(data.nodes)
            .force("link", d3.forceLink(data.links).id(d => d.id).distance(d => {
              // Make duplicate links shorter to pull duplicate files closer together
              return d.value === 3 ? 30 : 100;
            }))
            .force("charge", d3.forceManyBody().strength(-100))
            .force("center", d3.forceCenter(width / 2, height / 2));
  
          const link = container.append("g")
            .attr("class", "links")
            .selectAll("line")
            .data(data.links)
            .enter().append("line")
            .attr("class", d => {
              if (d.value === 3) return "duplicate";
              if (d.missing) return "missing-link";
              return "";
            })
            .attr("stroke", d => {
              if (d.missing) return "#d62728"; // Red for missing links
              if (d.value === 3) return "#9932cc"; // Purple for duplicates
              if (d.value === 2) return "#ff0000"; // Red for re-exports
              return "#999"; // Gray for regular imports
            })
            .attr("stroke-width", d => Math.sqrt(d.value || 1))
            .attr("stroke-dasharray", d => d.missing ? "5,5" : null);
  
          // Set initial display of duplicates based on checkbox
          const showDuplicates = document.getElementById('show-duplicates').checked;
          link.filter(d => d.value === 3) // Filter for duplicate connections
              .style("display", showDuplicates ? "inline" : "none");

          const node = container.append("g")
            .attr("class", "nodes")
            .selectAll("g")
            .data(data.nodes)
            .enter().append("g");
  
          // Add circles or X marks based on whether node is missing
          node.each(function(d) {
            const el = d3.select(this);
            if (d.missing) {
              // Create an X for missing nodes
              const size = 5;
              el.append("line")
                .attr("x1", -size)
                .attr("y1", -size)
                .attr("x2", size)
                .attr("y2", size)
                .attr("stroke", "#d62728")
                .attr("stroke-width", 2);
              
              el.append("line")
                .attr("x1", -size)
                .attr("y1", size)
                .attr("x2", size)
                .attr("y2", -size)
                .attr("stroke", "#d62728")
                .attr("stroke-width", 2);
            } else {
              // Regular node circle
              el.append("circle")
                .attr("r", 5)
                .attr("fill", d => {
                  if (d.group === 1) return "#1f77b4";
                  if (d.group === 2) return "#ff7f0e";
                  return "#2ca02c";
                });
            }
          });
  
          node.append("title")
            .text(d => d.missing ? `Missing: ${d.id}` : d.id);
  
          // Add text labels to nodes
          const nodeLabels = node.append("text")
            .attr("class", "node-label")
            .attr("dx", 8)
            .attr("dy", ".35em")
            .text(d => {
              const parts = d.id.split('/');
              return parts[parts.length - 1];
            })
            .style("fill", d => d.missing ? "#d62728" : "black")
            .style("font-style", d => d.missing ? "italic" : "normal");
          
          // Set initial display of labels based on checkbox
          const showLabels = document.getElementById('show-labels').checked;
          nodeLabels.style("display", showLabels ? "inline" : "none");
  
          simulation.on("tick", () => {
            link
              .attr("x1", d => d.source.x)
              .attr("y1", d => d.source.y)
              .attr("x2", d => d.target.x)
              .attr("y2", d => d.target.y);
  
            node.attr("transform", d => `translate(${d.x},${d.y})`);
          });
  
          // Add zoom functionality
          const zoom = d3.zoom()
            .scaleExtent([0.1, 10])
            .on("zoom", e => {
              container.attr("transform", e.transform);
            });
  
          svg.call(zoom);
          
          // Store current transform
          let currentTransform = d3.zoomIdentity;
          
          // Center button functionality
          document.getElementById('center-btn').addEventListener('click', () => {
            svg.transition().duration(750).call(
              zoom.transform,
              d3.zoomIdentity
            );
          });
          
          // Return key components for later use
          return {
            simulation,
            container,
            zoom,
            nodeLabels,
            links: link
          };
        }
        
        // Create initial visualization
        const viz = createVisualization(data);
        
        // Setup folder filter
        document.getElementById('folder-filter').addEventListener('change', function() {
          const folderPrefix = this.value;
          
          // Filter nodes
          let filteredNodes = originalData.nodes;
          if (folderPrefix) {
            filteredNodes = originalData.nodes.filter(node => 
              node.id.startsWith(folderPrefix) || (node.missing && document.getElementById('show-missing').checked)
            );
          } else if (!document.getElementById('show-missing').checked) {
            filteredNodes = originalData.nodes.filter(node => !node.missing);
          }
          
          // Get node IDs for link filtering
          const nodeIds = new Set(filteredNodes.map(n => n.id));
          
          // Filter links
          const filteredLinks = originalData.links.filter(link => {
            const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
            const targetId = typeof link.target === 'object' ? link.target.id : link.target;
            return nodeIds.has(sourceId) && nodeIds.has(targetId);
          });
          
          // Update visualization
          filteredData = {
            nodes: filteredNodes,
            links: filteredLinks
          };
          
          // Recreate visualization with filtered data
          createVisualization(filteredData);
        });
        
        // Show/hide missing nodes
        document.getElementById('show-missing').addEventListener('change', function() {
          // Re-trigger the folder filter to apply the missing nodes filter
          document.getElementById('folder-filter').dispatchEvent(new Event('change'));
        });
        
        // Show/hide node labels
        document.getElementById('show-labels').addEventListener('change', function() {
          const showLabels = this.checked;
          d3.selectAll(".node-label").style("display", showLabels ? "inline" : "none");
        });
        
        // Show/hide duplicate connections
        document.getElementById('show-duplicates').addEventListener('change', function() {
          const showDuplicates = this.checked;
          d3.selectAll(".links line.duplicate").style("display", showDuplicates ? "inline" : "none");
        });
        
        // Search functionality
        document.getElementById('search-btn').addEventListener('click', function() {
          const searchTerm = document.getElementById('search-input').value.toLowerCase();
          if (!searchTerm) return;
          
          const results = originalData.nodes.filter(node => 
            node.id.toLowerCase().includes(searchTerm)
          );
          
          const resultsContainer = document.getElementById('search-results');
          resultsContainer.style.display = results.length ? 'block' : 'none';
          
          if (results.length === 0) {
            resultsContainer.textContent = 'No results found';
          } else {
            resultsContainer.innerHTML = `Found ${results.length} results: <br>`;
            results.slice(0, 10).forEach(node => {
              const resultItem = document.createElement('div');
              resultItem.textContent = node.id;
              resultItem.style.cursor = 'pointer';
              resultItem.style.padding = '3px';
              resultItem.style.marginTop = '2px';
              resultItem.addEventListener('click', () => {
                // Find the node in the visualization and center on it
                const nodeInViz = filteredData.nodes.find(n => n.id === node.id);
                if (nodeInViz) {
                  // Center on this node
                  const transform = d3.zoomIdentity
                    .translate(width / 2, height / 2)
                    .scale(1.5)
                    .translate(-nodeInViz.x, -nodeInViz.y);
                  
                  svg.transition().duration(750).call(
                    viz.zoom.transform,
                    transform
                  );
                } else {
                  showError(`Node ${node.id} is not in the current filtered view.`);
                }
              });
              resultsContainer.appendChild(resultItem);
            });
            
            if (results.length > 10) {
              const more = document.createElement('div');
              more.textContent = `...and ${results.length - 10} more`;
              more.style.fontStyle = 'italic';
              more.style.marginTop = '5px';
              resultsContainer.appendChild(more);
            }
          }
        });
        
        // Allow pressing Enter in search box
        document.getElementById('search-input').addEventListener('keypress', function(e) {
          if (e.key === 'Enter') {
            document.getElementById('search-btn').click();
          }
        });
        
        // Debug functionality
        document.getElementById('inspect-data-btn').addEventListener('click', function() {
          console.log('Original data:', originalData);
          console.log('Filtered data:', filteredData);
          console.log('Missing nodes:', missingNodes);
          alert('Check the browser console for data inspection');
        });
      })
      .catch(error => {
        showError(`Error loading dependency data: ${error.message}`);
        console.error('Error:', error);
      });
  </script>
</body>
</html>